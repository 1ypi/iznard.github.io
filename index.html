<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Izan ‚Äî Cosmic Portfolio</title>
  <style>
    :root{--bg:#05060a;--accent:#7df9ff;--muted:#9aa6b2}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);font-family:'Inter',system-ui,sans-serif;color:#e6eef6;overflow:hidden}
    #intro{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;z-index:100;transition:opacity 0.5s}
    #intro.hidden{opacity:0;pointer-events:none}
    #startBtn{position:relative;width:140px;height:140px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:48px;cursor:pointer;border:3px solid rgba(255,255,255,0.1);background:linear-gradient(145deg,#ffb86b,#ff6b6b);box-shadow:0 10px 40px rgba(255,100,100,0.4);color:#fff;transition:transform 0.2s}
    #startBtn:hover{transform:scale(1.05)}
    #startBtn .label{position:absolute;bottom:-40px;font-size:13px;color:var(--muted);white-space:nowrap}
    .particle{position:absolute;width:6px;height:6px;border-radius:50%;pointer-events:none}
    #three-container{position:fixed;inset:0;z-index:1}
    #details{position:fixed;right:0;top:0;width:50%;height:100vh;background:rgba(5,6,10,0.98);padding:60px;overflow:auto;z-index:90;opacity:0;pointer-events:none;transition:opacity 0.5s}
    #details.open{opacity:1;pointer-events:all}
    #details h2{font-size:42px;margin:0 0 30px 0;color:var(--accent)}
    #details h3{font-size:20px;margin:25px 0 10px 0;color:#fff}
    #details p, #details li{font-size:16px;line-height:1.7;color:#c5d1de;margin:8px 0}
    #details ul{list-style:none;padding:0}
    #details li:before{content:"‚Ä¢ ";color:var(--accent);font-weight:bold;margin-right:8px}
    #backTop{position:fixed;left:20px;top:20px;padding:12px 16px;border-radius:8px;background:rgba(125,249,255,0.15);color:var(--accent);z-index:90;cursor:pointer;opacity:0;pointer-events:none;transition:opacity 0.3s;border:1px solid rgba(125,249,255,0.3);font-size:18px}
    #backTop.visible{opacity:1;pointer-events:all}
    #backTop:hover{background:rgba(125,249,255,0.25)}
    #footerTip{position:fixed;left:50%;bottom:25px;transform:translateX(-50%);color:var(--muted);font-size:14px;z-index:90;transition:opacity 0.5s}
  </style>
</head>
<body>
  <div id="intro">
    <button id="startBtn">üí•<div class="label">Haz click para crear el universo</div></button>
  </div>
  <div id="three-container"></div>
  <button id="backTop">‚Üê Volver</button>
  <div id="details">
    <div id="detailInner"></div>
  </div>
  <div id="footerTip">Izan ‚Äî Portfolio Interactivo</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  
  <script>
  const intro = document.getElementById('intro');
  const startBtn = document.getElementById('startBtn');
  const footerTip = document.getElementById('footerTip');
  const backTop = document.getElementById('backTop');
  const details = document.getElementById('details');
  const detailInner = document.getElementById('detailInner');
  const container = document.getElementById('three-container');

  let scene, camera, renderer, grid, planets = [], isZoomed = false;
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  const skillsData = {
    fisica: {
      name: "F√≠sica",
      icon: "‚öõÔ∏è",
      color: 0x7df9ff,
      size: 8,
      distance: 0,
      speed: 0,
      content: `<h2>‚öõÔ∏è F√≠sica</h2>
        <h3>Especializado en:</h3>
        <ul>
          <li>Mec√°nica Cl√°sica</li>
        </ul>
        <h3>Experienciado en:</h3>
        <ul>
          <li>Electromagnetismo</li>
          <li>Relatividad Especial</li>
          <li>Mec√°nica Orbital</li>
          <li>Teor√≠a At√≥mica</li>
          <li>Investigaci√≥n Cient√≠fica</li>
          <li>Propulsi√≥n</li>
          <li>Din√°mica Aerodin√°mica</li>
          <li>Optimizaci√≥n de Trayectorias Orbitales</li>
          <li>Simulaci√≥n Computacional</li>
        </ul>
        <h3>Estudiando:</h3>
        <ul>
          <li>Relatividad General</li>
          <li>Mec√°nica Cu√°ntica</li>
        </ul>`
    },
    matematicas: {
      name: "Matem√°ticas",
      icon: "‚à´",
      color: 0xff6b9d,
      size: 6,
      distance: 45,
      speed: 0.3,
      content: `<h2>‚à´ Matem√°ticas</h2>
        <h3>Especializado en:</h3>
        <ul>
          <li>C√°lculo I, II y III</li>
        </ul>
        <h3>Experienciado en:</h3>
        <ul>
          <li>C√°lculo Vectorial</li>
          <li>Teor√≠a de Conjuntos (Matem√°tica Discreta)</li>
          <li>Geometr√≠a</li>
          <li>Trigonometr√≠a</li>
          <li>√Ålgebra</li>
          <li>C√°lculo Tensorial</li>
        </ul>`
    },
    python: {
      name: "Python",
      icon: "üêç",
      color: 0xffd43b,
      size: 5,
      distance: 70,
      speed: 0.2,
      content: `<h2>üêç Python</h2>
        <h3>Especializado en:</h3>
        <ul>
          <li>Desarrollo de programas centrados en ciberseguridad/hacking √©tico</li>
        </ul>
        <h3>Proyectos Creados:</h3>
        <ul>
          <li>Lanzador de aplicaciones de Start Menu</li>
          <li>Calculadora Avanzada (integrales indefinidas, derivadas, etc.)</li>
          <li>Conversor de Binario a Decimal y viceversa</li>
          <li>Generador de contrase√±as seguras</li>
          <li>Comprobador de fuerza de contrase√±as b√°sico</li>
          <li>Comprobador de estado de p√°ginas web mediante requests</li>
        </ul>
        <h3>Proyectos en los que he contribuido:</h3>
        <ul>
          <li>Inteligencia Artificial como bot de Discord</li>
          <li>RAT (Remote Access Trojan)</li>
        </ul>`
    }
  };

  startBtn.addEventListener('click', () => {
    createBigBang();
    setTimeout(() => {
      intro.classList.add('hidden');
      footerTip.style.opacity = '0';
      setTimeout(() => {
        intro.style.display = 'none';
        initThreeJS();
      }, 500);
    }, 2000);
  });

  function createBigBang() {
    const particleCount = 300;
    const btnRect = startBtn.getBoundingClientRect();
    const centerX = btnRect.left + btnRect.width / 2;
    const centerY = btnRect.top + btnRect.height / 2;

    // Expanding sphere
    const sphere = document.createElement('div');
    sphere.style.position = 'absolute';
    sphere.style.left = centerX + 'px';
    sphere.style.top = centerY + 'px';
    sphere.style.width = '20px';
    sphere.style.height = '20px';
    sphere.style.borderRadius = '50%';
    sphere.style.background = 'radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(255,230,100,0.8) 40%, rgba(255,200,50,0) 100%)';
    sphere.style.boxShadow = '0 0 60px 30px rgba(255,255,255,0.8), 0 0 100px 50px rgba(255,230,100,0.6)';
    sphere.style.transform = 'translate(-50%, -50%)';
    sphere.style.pointerEvents = 'none';
    intro.appendChild(sphere);

    let sphereScale = 1;
    let sphereOpacity = 1;
    const animateSphere = () => {
      sphereScale += 0.15;
      sphereOpacity -= 0.008;
      sphere.style.transform = `translate(-50%, -50%) scale(${sphereScale})`;
      sphere.style.opacity = sphereOpacity;
      if (sphereOpacity > 0) {
        requestAnimationFrame(animateSphere);
      } else {
        sphere.remove();
      }
    };
    requestAnimationFrame(animateSphere);

    // Particles
    for (let i = 0; i < particleCount; i++) {
      const particle = document.createElement('div');
      particle.className = 'particle';
      const isWhite = Math.random() > 0.3;
      particle.style.background = isWhite ? '#ffffff' : '#ffeb3b';
      particle.style.left = centerX + 'px';
      particle.style.top = centerY + 'px';
      particle.style.boxShadow = `0 0 20px ${isWhite ? '#ffffff' : '#ffeb3b'}, 0 0 40px ${isWhite ? 'rgba(255,255,255,0.6)' : 'rgba(255,235,59,0.6)'}`;
      intro.appendChild(particle);

      const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
      const velocity = 4 + Math.random() * 10;
      const dx = Math.cos(angle) * velocity;
      const dy = Math.sin(angle) * velocity;

      let x = 0, y = 0, opacity = 1, scale = 1;

      const animate = () => {
        x += dx;
        y += dy;
        opacity -= 0.012;
        scale += 0.03;

        particle.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
        particle.style.opacity = opacity;

        if (opacity > 0) {
          requestAnimationFrame(animate);
        } else {
          particle.remove();
        }
      };
      
      requestAnimationFrame(animate);
    }
  }

  function initThreeJS() {
    scene = new THREE.Scene();

    renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);
    
    camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 80, 120);
    camera.lookAt(0, 0, 0);
    
    const ambient = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambient);
    
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(20, 50, 30);
    scene.add(dir);

    createSpacetimeGrid();
    createPlanets();
    animate();

    renderer.domElement.addEventListener('click', onMouseClick);
    window.addEventListener('resize', onWindowResize);
    backTop.addEventListener('click', resetView);
  }

  function createSpacetimeGrid() {
    const GRID_SIZE = 300;
    const GRID_SEG = 150;
    const geom = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE, GRID_SEG, GRID_SEG);
    geom.rotateX(-Math.PI/2);
    
    const vertices = geom.attributes.position;
    for (let i = 0; i < vertices.count; i++) {
      const x = vertices.getX(i);
      const z = vertices.getZ(i);
      let y = 0;
      
      // F√≠sica (centro) - mayor hundimiento
      const distPhysics = Math.sqrt(x*x + z*z);
      y -= 15 / (1 + distPhysics * 0.15);
      
      // Matem√°ticas
      Object.keys(skillsData).forEach(key => {
        if (key !== 'fisica') {
          const skill = skillsData[key];
          const angle = skill.speed * Date.now() * 0.001;
          const px = Math.cos(angle) * skill.distance;
          const pz = Math.sin(angle) * skill.distance;
          const dist = Math.sqrt((x-px)*(x-px) + (z-pz)*(z-pz));
          const mass = skill.size * 0.8;
          y -= mass / (1 + dist * 0.2);
        }
      });
      
      vertices.setY(i, y);
    }
    
    const mat = new THREE.ShaderMaterial({
      vertexShader: `
        varying vec3 vPos; 
        varying float vViewZ; 
        void main(){ 
          vPos = position; 
          vec4 mv = modelViewMatrix * vec4(position, 1.0); 
          vViewZ = -mv.z; 
          gl_Position = projectionMatrix * mv; 
        }`,
      fragmentShader: `
        varying vec3 vPos; 
        varying float vViewZ; 
        void main(){ 
          float depthFade = smoothstep(10.0, 250.0, vViewZ); 
          float alpha = 0.9 - pow(depthFade, 0.8); 
          float dist2 = length(vPos.xz); 
          float edgeFade = 1.0 - smoothstep(120.0, 280.0, dist2); 
          alpha *= edgeFade; 
          gl_FragColor = vec4(1.0, 1.0, 1.0, alpha * 0.6); 
        }`,
      transparent: true, 
      wireframe: true,
      depthWrite: false
    });
    
    grid = new THREE.Mesh(geom, mat);
    grid.userData.isGrid = true;
    scene.add(grid);
  }

  function createPlanets() {
    Object.keys(skillsData).forEach(key => {
      const skill = skillsData[key];
      
      // Create a group to hold circle and icon
      const group = new THREE.Group();
      
      // Circle background as sprite (always faces camera)
      const circleCanvas = document.createElement('canvas');
      circleCanvas.width = 512;
      circleCanvas.height = 512;
      const circleCtx = circleCanvas.getContext('2d');
      
      // Clear background (transparent)
      circleCtx.clearRect(0, 0, 512, 512);
      
      // Draw circle
      circleCtx.beginPath();
      circleCtx.arc(256, 256, 240, 0, Math.PI * 2);
      circleCtx.fillStyle = `rgba(${(skill.color >> 16) & 255}, ${(skill.color >> 8) & 255}, ${skill.color & 255}, 0.3)`;
      circleCtx.fill();
      
      // Draw glow ring
      circleCtx.strokeStyle = `rgba(${(skill.color >> 16) & 255}, ${(skill.color >> 8) & 255}, ${skill.color & 255}, 0.6)`;
      circleCtx.lineWidth = 8;
      circleCtx.stroke();
      
      const circleTexture = new THREE.CanvasTexture(circleCanvas);
      const circleSpriteMat = new THREE.SpriteMaterial({map: circleTexture, transparent: true});
      const circleSprite = new THREE.Sprite(circleSpriteMat);
      circleSprite.scale.set(skill.size * 2.2, skill.size * 2.2, 1);
      group.add(circleSprite);
      
      // Icon sprite
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      
      // Glow effect
      const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
      gradient.addColorStop(0, `rgba(${(skill.color >> 16) & 255}, ${(skill.color >> 8) & 255}, ${skill.color & 255}, 0.4)`);
      gradient.addColorStop(0.5, `rgba(${(skill.color >> 16) & 255}, ${(skill.color >> 8) & 255}, ${skill.color & 255}, 0.2)`);
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 256, 256);
      
      // Icon
      ctx.fillStyle = '#ffffff';
      ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
      ctx.shadowBlur = 20;
      ctx.font = 'bold 140px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(skill.icon, 128, 138);
      
      const texture = new THREE.CanvasTexture(canvas);
      const spriteMat = new THREE.SpriteMaterial({map: texture, transparent: true});
      const sprite = new THREE.Sprite(spriteMat);
      sprite.scale.set(skill.size * 1.5, skill.size * 1.5, 1);
      sprite.position.z = 0.1; // Slightly in front of circle
      group.add(sprite);
      
      group.userData.skill = key;
      group.userData.skillData = skill;
      group.userData.sprite = sprite;
      group.userData.circleSprite = circleSprite;
      
      scene.add(group);
      planets.push(group);
    });
  }

  function animate() {
    requestAnimationFrame(animate);
    
    if (!isZoomed) {
      const time = Date.now() * 0.001;
      
      planets.forEach(planet => {
        const skill = planet.userData.skillData;
        if (skill.distance === 0) {
          planet.position.set(0, 0, 0);
        } else {
          const angle = time * skill.speed;
          planet.position.x = Math.cos(angle) * skill.distance;
          planet.position.z = Math.sin(angle) * skill.distance;
          planet.position.y = 0;
        }
      });
      
      // Actualizar grid
      if (grid) {
        const vertices = grid.geometry.attributes.position;
        for (let i = 0; i < vertices.count; i++) {
          const x = vertices.getX(i);
          const z = vertices.getZ(i);
          let y = 0;
          
          planets.forEach(planet => {
            const px = planet.position.x;
            const pz = planet.position.z;
            const dist = Math.sqrt((x-px)*(x-px) + (z-pz)*(z-pz));
            const mass = planet.userData.skillData.size * (planet.userData.skill === 'fisica' ? 1.5 : 0.8);
            y -= mass / (1 + dist * 0.2);
          });
          
          vertices.setY(i, y);
        }
        vertices.needsUpdate = true;
      }
    }
    
    renderer.render(scene, camera);
  }

  function onMouseClick(event) {
    if (isZoomed) return;
    
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(planets, true);
    
    if (intersects.length > 0) {
      let planet = intersects[0].object;
      // Find the parent group if we clicked on a child object
      while (planet && !planet.userData.skillData) {
        planet = planet.parent;
      }
      if (planet && planet.userData.skillData) {
        zoomToPlanet(planet);
      }
    }
  }

  function zoomToPlanet(planet) {
    isZoomed = true;
    const targetPos = planet.position.clone();
    
    // Ocultar otros planetas y grid
    planets.forEach(p => {
      if (p !== planet) p.visible = false;
    });
    if (grid) grid.visible = false;
    
    // Animar c√°mara y mover logo a la izquierda
    const startPos = camera.position.clone();
    const endPos = new THREE.Vector3(targetPos.x, targetPos.y, targetPos.z + 40);
    const startTime = Date.now();
    const duration = 1000;
    
    // Move planet/logo to the left during zoom
    const startPlanetX = targetPos.x;
    const endPlanetX = targetPos.x - 20;
    
    function animateCamera() {
      const elapsed = Date.now() - startTime;
      const t = Math.min(elapsed / duration, 1);
      const eased = t < 0.5 ? 2*t*t : -1+(4-2*t)*t;
      
      camera.position.lerpVectors(startPos, endPos, eased);
      camera.lookAt(targetPos);
      
      // Move planet to the left
      planet.position.x = startPlanetX + (endPlanetX - startPlanetX) * eased;
      
      if (t < 1) {
        requestAnimationFrame(animateCamera);
      } else {
        showDetails(planet.userData.skillData);
      }
    }
    animateCamera();
  }

  function showDetails(skillData) {
    detailInner.innerHTML = skillData.content;
    details.classList.add('open');
    backTop.classList.add('visible');
  }

  function resetView() {
    isZoomed = false;
    details.classList.remove('open');
    backTop.classList.remove('visible');
    
    // Mostrar todo
    planets.forEach(p => p.visible = true);
    if (grid) grid.visible = true;
    
    // Animar c√°mara de vuelta
    const startPos = camera.position.clone();
    const endPos = new THREE.Vector3(0, 80, 120);
    const startTime = Date.now();
    const duration = 1000;
    
    function animateCamera() {
      const elapsed = Date.now() - startTime;
      const t = Math.min(elapsed / duration, 1);
      const eased = t < 0.5 ? 2*t*t : -1+(4-2*t)*t;
      
      camera.position.lerpVectors(startPos, endPos, eased);
      camera.lookAt(0, 0, 0);
      
      if (t < 1) {
        requestAnimationFrame(animateCamera);
      }
    }
    animateCamera();
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }
  </script>
</body>
</html>
